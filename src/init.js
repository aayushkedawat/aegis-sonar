// src/init.js
import fs from "node:fs";
import path from "node:path";
import { execa } from "execa";
import kleur from "kleur";

/* ------------------------------ colors ------------------------------ */
const useColor = !process.env.NO_COLOR;
const c = {
  ok: (s) => (useColor ? kleur.green().bold(s) : s),
  err: (s) => (useColor ? kleur.red().bold(s) : s),
  warn: (s) => (useColor ? kleur.yellow().bold(s) : s),
  info: (s) => (useColor ? kleur.cyan(s) : s),
  dim: (s) => (useColor ? kleur.dim(s) : s),
  head: (s) => (useColor ? kleur.bold().underline(s) : s),
};

/* ------------------------------ helpers ----------------------------- */

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

async function getGitDirOrNull() {
  try {
    const { stdout } = await execa("git", ["rev-parse", "--git-dir"]);
    return stdout.trim();
  } catch {
    return null;
  }
}

async function setHooksPath(hooksPath) {
  await execa("git", ["config", "core.hooksPath", hooksPath]);
}

function writeFileIfNeeded(filePath, content, opts = {}) {
  const { force = false, mode } = opts;
  if (fs.existsSync(filePath) && !force) return "skipped";
  fs.writeFileSync(filePath, content, { encoding: "utf-8", mode });
  return fs.existsSync(filePath) ? "written" : "error";
}

function isWindows() {
  return process.platform === "win32";
}

function readPkgNameOrNull() {
  try {
    const raw = fs.readFileSync("package.json", "utf-8");
    const name = JSON.parse(raw)?.name;
    return typeof name === "string" ? name : null;
  } catch {
    return null;
  }
}

function sanitizeProjectKey(s) {
  return String(s ?? "")
    .trim()
    .toLowerCase()
    .replaceAll(/[^a-z0-9:_./-]+/g, "-")
    .replaceAll(/(?:^-+|-+$)/g, ""); // group the two alternatives explicitly
}

/* --------------------------- static templates ------------------------ */

const POSIX_HOOK = `#!/bin/sh
# Aegis pre-push (POSIX)
# Quiet by default; add --print-issues locally if you want console output
npx --no-install aegis run "$@"
status=$?
if [ $status -ne 0 ]; then
  echo "Aegis blocked push (Quality Gate failed). See saved issues file."
fi
exit $status
`;

const WIN_HOOK = `@echo off
REM Aegis pre-push (Windows)
npx --no-install aegis run %*
set EXITCODE=%ERRORLEVEL%
if NOT %EXITCODE%==0 (
  echo Aegis blocked push (Quality Gate failed). See saved issues file.
  exit /b %EXITCODE%
)
exit /b 0
`;

function sonarPropsTemplate({ host, key, name, sources }) {
  const today = new Date().toISOString().slice(0, 10);
  return [
    "# Generated by Aegis init on " + today,
    "# Adjust values as needed. SONAR_TOKEN must be set in your env.",
    "",
    `sonar.host.url=${host}`,
    `sonar.projectKey=${key}`,
    `sonar.projectName=${name}`,
    `sonar.sources=${sources}`,
    "sonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/.next/**",
    "",
    "# Optional JS/TS settings (uncomment if needed):",
    "# sonar.javascript.lcov.reportPaths=coverage/lcov.info",
    "# sonar.typescript.tsconfigPath=tsconfig.json",
    "",
  ].join("\n");
}

function aegisRcTemplate() {
  // default issuesFile has no extension; run-time adds .md/.txt/.json
  return (
    JSON.stringify(
      {
        severities: "BLOCKER,CRITICAL,MAJOR",
        types: "BUG,VULNERABILITY,CODE_SMELL",
        max: 500,
        issuesFile: "sonar-issues",
        format: "md",
      },
      null,
      2
    ) + "\n"
  );
}

/* ---------------------------- small tasks ---------------------------- */

function normalizeLfAndChmod(posixPath) {
  try {
    const lf = fs.readFileSync(posixPath, "utf-8").replaceAll("\r\n", "\n");
    fs.writeFileSync(posixPath, lf, "utf-8");
  } catch {}
  try {
    if (!isWindows()) fs.chmodSync(posixPath, 0o755);
  } catch {}
}

function labelWriteResult(res) {
  if (res === "written") return c.ok("created");
  if (res === "skipped") return c.dim("exists (skipped)");
  return c.err("error");
}

/* ------------------------- scaffold sub-steps ------------------------- */

async function scaffoldHooks({ hooksPath, force }) {
  ensureDir(hooksPath);
  await setHooksPath(hooksPath);

  // show what Git sees now
  let effective = hooksPath;
  try {
    const { stdout } = await execa("git", ["config", "core.hooksPath"]);
    effective = (stdout || "").trim() || hooksPath;
  } catch {}

  console.log(c.ok("âœ”"), "hooksPath set to", c.dim(effective));

  const posixPath = path.join(hooksPath, "pre-push");
  const winPath = path.join(hooksPath, "pre-push.cmd");

  const posixRes = writeFileIfNeeded(posixPath, POSIX_HOOK, {
    force,
    mode: 0o755,
  });
  if (posixRes === "written") normalizeLfAndChmod(posixPath);

  const winRes = writeFileIfNeeded(winPath, WIN_HOOK, { force });

  console.log(
    c.info("â€¢ POSIX hook:"),
    c.dim(posixPath),
    "-",
    labelWriteResult(posixRes)
  );
  console.log(
    c.info("â€¢ Windows hook:"),
    c.dim(winPath),
    "-",
    labelWriteResult(winRes)
  );
}

function scaffoldSonarProps({
  force,
  hostFlag,
  keyFlag,
  nameFlag,
  sourcesFlag,
}) {
  const sonarFile = "sonar-project.properties";
  const exists = fs.existsSync(sonarFile);

  if (exists && !force) {
    console.log(
      c.info("â€¢ sonar-project.properties:"),
      c.dim("exists (skipped)")
    );
    return "skipped";
  }

  const key = "your-project-id";
  const name = "your-project-name";
  const host = hostFlag || "https://your-sonarqube.example.com";
  const sources = sourcesFlag || ".";

  const content = sonarPropsTemplate({ host, key, name, sources });
  const res = writeFileIfNeeded(sonarFile, content, { force });
  console.log(c.info("â€¢ sonar-project.properties:"), labelWriteResult(res));
  return res;
}

function scaffoldAegisRc() {
  const rcFile = ".aegisrc.json";
  if (fs.existsSync(rcFile)) {
    console.log(c.info("â€¢ .aegisrc.json:"), c.dim("exists (skipped)"));
    return "skipped";
  }
  const res = writeFileIfNeeded(rcFile, aegisRcTemplate(), { force: false });
  console.log(c.info("â€¢ .aegisrc.json:"), labelWriteResult(res));
  return res;
}

function finalHints({ didHooks, sonarStatus }) {
  console.log("");
  if (didHooks) {
    console.log(
      c.ok("âœ”"),
      "Aegis pre-push hook setup complete.",
      c.dim("(use --force to overwrite existing files)")
    );
  }
  if (sonarStatus === "written") {
    console.log(
      c.info("â„¹"),
      "Update",
      c.dim("sonar.host.url"),
      "and",
      c.dim("sonar.projectKey"),
      "if needed. Then export",
      c.dim("SONAR_TOKEN"),
      "before running:",
      c.dim("npx aegis run")
    );
  }
  console.log(
    c.info("â„¹"),
    "If your GUI doesnâ€™t fire hooks, verify",
    c.dim("git config core.hooksPath"),
    "and presence of",
    c.dim("pre-push"),
    "and",
    c.dim("pre-push.cmd") + "."
  );
}

/* -------------------------------- init ------------------------------- */

export async function initHook(argv = {}) {
  const force = Boolean(argv.force);

  // default true; explicit --scaffold=false allows skipping hooks while still writing config files
  const scaffold = argv.scaffold !== false;

  // hooks path
  const hooksPath = String(argv.hooksPath || ".githooks");

  // sonar flags (support kebab and camel)
  const hostFlag = argv.sonarHost || argv["sonar-host"] || "";
  const keyFlag = argv.projectKey || argv["project-key"] || "";
  const nameFlag = argv.projectName || argv["project-name"] || "";
  const sourcesFlag = argv.sources || "";

  console.log(c.head("ðŸ”§ Aegis setup"));

  const gitDir = await getGitDirOrNull();
  if (!gitDir) {
    console.error(
      c.err("âœ–"),
      "Not a Git repository or git not available on PATH."
    );
    process.exit(1);
  }

  // A) Hooks (optional, default on)
  if (scaffold) {
    await scaffoldHooks({ hooksPath, force });
  } else {
    console.log(c.dim("Skipping hook scaffold (scaffold=false)."));
  }

  // B) sonar-project.properties
  const sonarStatus = scaffoldSonarProps({
    force,
    hostFlag,
    keyFlag,
    nameFlag,
    sourcesFlag,
  });

  // C) .aegisrc.json (nice DX)
  scaffoldAegisRc();

  // D) Final hints & exit
  finalHints({ didHooks: scaffold, sonarStatus });
}
